//
// Created by zhanghao on 22-9-6.
//
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <unistd.h>
//一个现有的进程调用函数fork创建一个新的进程
//子进程和父进程继续执行fork函数后的代码
//fork函数调用一次，返回两次。（可以这么理解，在进入fork前只有一个进程，然后在fork函数中产生了一个新的子进程。也就是在fork中一个进程分叉成了两个进程，接下来子进程
// 和父进程都要从fork函数中返回。所以fork()函数返回了两次，子进程返回0，父进程返回子进程的的进程id（大于0）。fork（）之后，父进程和子进程都执行fork之后的代码
// ，虽然后面的代码都是相同的，但是我们可以利用fork()函数的返回值使父子进程进入不同的执行流程，执行不同的任务
// ）
// fork()如果返回-1，说明创建进程失败，可能是内存不够。
//子进程返回0，父进程返回子进程的进程ID
//子进程是父进程的副本。
//子进程获得了父进程的数据空间、堆和站的副本，不是共享
//如果父进程先退出，子进程会成为孤儿进程，将被1号进程对他们完成状态收集工作
//如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。
/* 如果子进程在父进程之前终止，内核为每个子进程保留了一个数据结构，这个数据结构包括进程编号、终止状态、和使用CPU时间等，父进程如果处理了
 * 子进程退出的信息，内核就会释放这个数据结构，如果父进程没有处理子进程退出的的信息，内核就不会释放这个数据结构，子进程进程编号就会一直被占用，
 * 但是系统可用的进程号是有限的，如果大量的产生僵尸死进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。
 * */
/*
int main(){
    int pid = fork();
    //printf("pid = %d",pid);
    //sleep(1);
    if(pid == 0){
        printf("这是子进程%d,将执行子进程的任务。\n",getpid());
        sleep(10);
    }
    if(pid > 0){
        printf("这是父进程%d,将执行父进程的任务。\n",getpid());
        sleep(10);
    }
    return 0;
}
 */
int main()
{
    int ii = 1;
    int pid = fork();
    if(pid == 0)
    {
        printf("这是子进程%d,将执行子进程的任务。 \n", getpid());
        printf("这是子进程 aaa ii = %d\n", ii++); sleep(1);
        printf("这是子进程 aaa ii = %d\n", ii++); sleep(1);
        printf("这是子进程 aaa ii = %d\n", ii++); sleep(1);
    }

    if(pid > 0)
    {
        printf("这是父进程%d, 将执行父进程的任务。\n", getpid());
        printf("这是父进程 aaa ii = %d\n", ii); sleep(1);
        printf("这是父进程 aaa ii = %d\n", ii); sleep(1);
        printf("这是父进程 aaa ii = %d\n", ii); sleep(1);
    }
}




